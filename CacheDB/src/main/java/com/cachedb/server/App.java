/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.cachedb.server;

import com.cachedb.server.Expiration.Expiration;
import com.cachedb.server.commands.*;
import com.cachedb.server.constants.Constants;
import com.cachedb.server.inputValidator.InputValidator;

import java.util.Arrays;
import java.util.Scanner;
import java.util.concurrent.*;

public class App {
    public static void main(String[] args)  {
        Scanner sc = new Scanner(System.in);

        //Expiration of the keys service
        Expiration expirationService = new Expiration();

        while(true){

            //Extracting input into array of Strings
            String input = sc.nextLine();
            String[] parts = input.split(" ");

            //EXIT condition -> prints and clears memory
            if (parts[0].equalsIgnoreCase(Constants.EXIT)) {
                System.out.println("Adios!");
                Services.clearMemory();
                break;
            }


            try{
                //Callable interface, it selects which command to execute based on input
                Callable<String> command = switch (parts[0].toUpperCase()) {
                    //PUT case
                    case Constants.PUT -> {
                        if (InputValidator.validatePUT(input)) {
                            yield new PutCommand(parts);
                        } else {
                            yield new InvalidCommand();
                        }
                    }
                    //GET case
                    case Constants.GET -> {
                        if (InputValidator.validateSingle(input)) {
                            yield new GetCommand(parts[1]);
                        } else {
                            yield new InvalidCommand();
                        }
                    }
                    //SAVE case
                    case Constants.SAVE -> {
                        if (InputValidator.validateSingle(input)) {
                            yield new SaveCommand(parts[1]);
                        } else {
                            yield new InvalidCommand();
                        }
                    }
                    //DEL case
                    case Constants.DEL -> {
                        if (InputValidator.validateSingle(input)) {
                            yield new DelCommand(parts[1]);
                        } else {
                            yield new InvalidCommand();
                        }
                    }
                    //MDEL case
                    case Constants.MDEL -> {
                        if (InputValidator.validateMDEL(input)) {
                            yield new DelCommand(parts);
                        } else {
                            yield new InvalidCommand();
                        }
                    }
                    //MGET case
                    case Constants.MGET -> {
                        if (InputValidator.validateMGET(input)) {
                            yield new GetCommand(parts);
                        } else {
                            yield new InvalidCommand();
                        }
                    }
                    //MPUT case
                    case Constants.MPUT -> {
                        if (InputValidator.validateMPUT(input)) {
                            yield new PutCommand(parts, true);
                        } else {
                            yield new InvalidCommand();
                        }
                    }
                    default -> new InvalidCommand();
                };

                //Applying executor service with 3 threads and making them all daemon thread
                ExecutorService executorService = Executors.newFixedThreadPool(3,
                        r -> {
                            Thread t = Executors.defaultThreadFactory().newThread(r);
                            t.setDaemon(true);
                            return t;
                        });
                Future<String> future = executorService.submit(command);

                //printing the result
                System.out.println(future.get());
            } catch (ExecutionException | InterruptedException | RuntimeException e) {
                System.out.println(e.getMessage());
            }

        }
        sc.close();
    }
}